/*
 *  This class will compute The RSA algorithm for every user that connects
 *  to the server chat program. Every user will have their own private and public key
 *  
 *  Note: - implementation for block sizes is still undecided, which will determine the minimum product size
 *          of two prime numbers
 *        - Primality test still not implemented. currently researching the best algorithm that is computationally fast
 *          and not incredibly difficult to code.
 */
package Securitypkg;

import java.math.BigInteger;
import java.util.*;


public class RSA
{
	// numbers that must be prime
	private BigInteger p;
	private BigInteger q;
	
	// computed using the values p and q 
	private BigInteger n;
	private BigInteger m;
	
	// computed using m
	private BigInteger e;
	private BigInteger d;
	
	// private and public keys generated by the RSA algorithm
	private PublicKey pubKey;
	private PrivateKey privKey;
	
	// validity check for caller of the object
	private boolean validPrimes = false;
	
	
	//constructor
	// @Param p - passed in to compute rsa algorithm, must be prime
	// @Param q - passed in to compute rsa algorithm, must be prime
	public RSA(BigInteger p, BigInteger q)
	{
		this.q = q;
		this.p = p;
			
		n = p.multiply(q);
		MillerRabinTest primeTest = new MillerRabinTest(p, q);
		
		// test numbers to check if greater than 128^4 and if both are prime
		if((n.compareTo(BigInteger.valueOf((128 << 4))) > 0) && primeTest.isPrime())
			validPrimes = true;
		else
			validPrimes = false;
			
		// m = (p - 1) * (q- 1)
		m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));
		
		e = findFirstE();
		d = findD();
		
		pubKey = new PublicKey(n, e);
		privKey = new PrivateKey(n, d);
	}
	
	
	
	// This attempts to find a potential 'e' for the RSA algorithm 
	// where the gcd for e and m is 1.
	private BigInteger findFirstE()
	{
		// make object that will compute gcd
		EuclidianAlgorithm ea = new EuclidianAlgorithm(BigInteger.valueOf(2), m);
		ea.computeGCD();
		BigInteger gcd = ea.getGCD();
		
		// initialize potentialE
		BigInteger potentialE = BigInteger.valueOf(2);
		
		// loop until the gcd for e and m is 1
		// gcd != 1
		while(!gcd.equals(BigInteger.valueOf(1)))
		{
			potentialE = potentialE.add(BigInteger.valueOf(1));
			
			ea.setNewNumbers(potentialE, m);
			ea.computeGCD();
			gcd = ea.getGCD();
		}
		
		return potentialE;
	}
	
	// computes the value for D by continually looping and incrementing until the equation
	// equals 0 meaning the value 'k' managed to make the equation divisible by e
	// @Return returns the 'd' value needed for the algorithm
	private BigInteger findD()
	{
		BigInteger potentialK = BigInteger.valueOf(0);
		BigInteger potentialD = BigInteger.valueOf(-1);
		
		// (1 + k*m) % e  != 0
		while(!((((potentialK.multiply(m)).add(BigInteger.ONE)).mod(e)).equals(BigInteger.ZERO)))
			potentialK = potentialK.add(BigInteger.valueOf(1));
		
		
		potentialD = ((potentialK.multiply(m)).add(BigInteger.valueOf(1))).divide(e);
		
		return potentialD;
	}
	
	// encrypts a String that the caller intends to send over the network in order to 
	// avoid other users from intercepting the message and reading it
	// @Param msg - the string message that the caller intends to send
	// @Return Vector<BigInteger> - the String encoded into several blocks inside a vector is returned
	public static Vector<BigInteger> encryptM(String msg, Vector<BigInteger> recieverKey)
	{	
		//BigInteger recieverE = recieverKey.getE();
		//BigInteger recieverN = recieverKey.getN();
		// initialize variables for computing the blocking algorithm
		int asciiVer[] = new int[msg.length()];
		Vector <BigInteger> block = new Vector<BigInteger>();
		BigInteger total = BigInteger.ZERO;
		int i = 0;
		
		// convert each character into the ascii value representation
		for(i = 0; i < msg.length(); i++)
			asciiVer[i] = (int) msg.charAt(i);
		
		// compute the blocking algorithm for the whole message where each block will contain at most 4 characters
		for(i = 0; i < asciiVer.length; i++)
		{
			// char*128^i
			BigInteger calculation = ( BigInteger.valueOf(asciiVer[i]) ).multiply( ( BigInteger.valueOf(128) ).pow(i % 4) );
			
			// every four characters reset variables to keep each block at 4 characters
			if( (i != 0) && (i % 4 == 0) )
			{
				block.add(total);
				total = BigInteger.ZERO;
				total = total.add(calculation);
			}
			else
			{
				total = total.add(calculation);
			}
		}
		
		// add any stray values that were left behind
		if(i-1 % 4 != 0)
			block.add(total);
		
		// encode each block with the rsa algorithm using the public key
		for(int j = 0; j < block.size(); j++)
		{
			 BigInteger b = block.elementAt(j);
			 BigInteger encodedBlock = b.modPow(recieverKey.elementAt(1), recieverKey.elementAt(0));
			 block.set(j, encodedBlock);
		}
			
		return block;
	}
	
	// method that decrypts multiple blocks and converts them to string that is then sent
	// back to the caller
	// @Param encryptedBlock - the vector block that contains a message that is encrypted with a public key
	// @Return String - the message that was decoded from the vector block passed in as a parameter
	public String decryptM(Vector<BigInteger> encryptedBlock)
	{
		String decryptedMessage = "";
		
		// initialize values that will be used for bit masking to get characters back
		BigInteger sevenBits = BigInteger.valueOf(0x7F);
		
		// decode the blocks
		for(int i = 0; i < encryptedBlock.size(); i++)
		{
			BigInteger b = encryptedBlock.elementAt(i);
			BigInteger db = b.modPow(d, n);
			encryptedBlock.set(i, db);
		}
		
		// undo the blocking algorithm done by encryption method and extract the characters
		for(int i = 0; i < encryptedBlock.size(); i++)
		{
			String fourChars = "";
			BigInteger chosenBlock = encryptedBlock.elementAt(i);
			
			// iterate 4 times because thats how many chars are in each block
			for(int j = 0; j < 4; j++)
			{
				BigInteger shiftedBits = sevenBits.shiftLeft(j*7);
				BigInteger savedBits = chosenBlock.and(shiftedBits);
				
				savedBits = savedBits.shiftRight(j*7);
				int extractedInt = savedBits.intValue();
				fourChars = fourChars + (char) extractedInt;
			}
			
			decryptedMessage = decryptedMessage.concat(fourChars);
		}
		
		//System.out.println(decryptedMessage);
		return decryptedMessage;
	}
	
	// returns public key as an integer array of size 2
	public Vector<BigInteger> getPubKey()
	{
		Vector<BigInteger> publicKey = new Vector<BigInteger>();
		publicKey.add(pubKey.getN());
		publicKey.add(pubKey.getE());
		return publicKey;
	}
	
	// returns true if values passed into constructor passed the primality test
	// returns false if values passed failed the primality test
	public boolean isInputValid()
	{
		return validPrimes;
	}
	
	
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	// 					Methods mainly used for JUnit testing
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	//--------------------------------------------------------------------------------
	
	public BigInteger getPVal()
	{
		return p;
	}
	
	public BigInteger getQVal()
	{
		return q;
	}
	
	public BigInteger getNVal()
	{
		return n;
	}
	
	public BigInteger getMVal()
	{
		return m;
	}
	
	public BigInteger getE()
	{
		return e;
	}
	
	public BigInteger getDVal()
	{
		return d;
	}
	
	public static BigInteger getGCD(BigInteger num1, BigInteger num2)
	{
		EuclidianAlgorithm e = new EuclidianAlgorithm(num1, num2);
		e.computeGCD();
		return e.getGCD();
	}
	
}
